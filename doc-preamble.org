* About this document

This Blocky reference guide collects all the documentation from the
[[http://github.com/dto/blocky][Blocky source code repository]] into one document. The file [[https://github.com/dto/blocky/blob/master/doc.lisp][doc.lisp]]
contains the code for the extraction, which reformats the docstrings
as an alphabetized, indexed file for [[http://orgmode.org][Emacs Orgmode]]. Org-mode can
easily export its files to HTML, LaTeX, and various other formats.

The latest version of this document may be found at
http://blocky.io/reference.html.

* Overview of prototype-based programming

Blocky is built on an alternative view of object-orientation called
[[http://en.wikipedia.org/wiki/Prototype-based_programming][Prototype-based programming.]] Instead of partitioning the objects in
your program into classes that share inheritance relationships, the
objects in a prototype-based system inherit behavior and data directly
from each other through "cloning". The cloning process takes an
existing object and creates a new object with a link to the
original---now called a "superobject"---from which it will inherit
methods and data fields. When a method is invoked (or a field is
referenced) and no local value is found, the superobject is checked
for a value, and then its superobject if any, and so on. Methods are
stored in fields, so if you want to replace a clone's method
definition with something else, just define the new method on the
clone, and the superobject's version will be hidden.

See the heading "Block (prototype)" for an overview of the Blocky
language model and Lisp API.

* A quick tour of prototypes in Blocky

** Defining a prototype

First we must define a prototype and name its fields:

: (define-prototype rectangle ()
:   x y width height)

We could also have provided initialization forms for the fields, and
documentation strings:

: (define-prototype rectangle ()
:   (x :initform 0 
:      :documentation "The x-coordinate of the rectangle's top-left corner.")
:   (y :initform 0 
:      :documentation "The y-coordinate of the rectangle's top-left corner.")
:   (width :documentation "The width of the rectangle.")
:   (height :documentation "The height of the rectangle."))

** Single inheritance, with :SUPER

And if there was a "shape" prototype, from which we would like
"rectangle" to inherit data and methods, we might have written:

: (define-prototype rectangle (:super shape)
:   (x :initform 0 
:      :documentation "The x-coordinate of the rectangle's top-left corner.")
:   (y :initform 0 
:      :documentation "The y-coordinate of the rectangle's top-left corner.")
:   (width :documentation "The width of the rectangle.")
:   (height :documentation "The height of the rectangle."))

** Cloning objects with NEW

The function NEW is used to create new objects from these
prototypes. Now we write an initializer, which is passed any creation
arguments at the time of cloning.

: (define-method initialize rectangle (&key width height)
:   (setf %width width)
:   (setf %height height))

So, now when you say:

: (let ((my-rectangle
:       (new rectangle :width 5 :height 12)))

The rectangle's initializer method is invoked with those arguments,
and a rectangle of the correct height and width is created.

Notice how field accesses can be written with the percent-sign prefix;
this works both for reading and for writing, so long as you use "setf"
for the latter. You can also get or set field values with the
underlying function FIELD-VALUE:
 
: (field-value :width my-rectangle)
: (setf (field-value :height my-rectangle) 7)

** Methods

Now we define a few methods, which are functions whose implicit first
argument is the object to operate on.

: (define-method area rectangle ()
:   (* %width %height))
: 
: (define-method print-me rectangle (&optional (stream t))
:   (format stream "height: ~A width: ~A area: ~A"
: 	  %height %width 
: 	  (area self)))

You can invoke them like ordinary functions, or use the SEND function.

: (defvar rect (new rectangle :width 10 :height 8))
: ;; these two are equivalent:
: (print-me rect)
: (send :print-me rect)

The result: 

: "height: 8 width: 10 area: 80"

Notice how within the body of PRINT-ME, the variable "self" refers to
the object being operated on. So it's easy to see why %foo expands to
(field-value :foo self)

** TODO Extended argument lists
** TODO Serialization


