#+TITLE: A programmer's guide to Blocky internals

* Overview of prototype-based programming

Blocky is built on an alternative view of object-orientation called
[[http://en.wikipedia.org/wiki/Prototype-based_programming][Prototype-based programming.]] Instead of partitioning the objects in
your program into classes that share inheritance relationships, the
objects in a prototype-based system inherit behavior and data directly
from each other through /cloning/. The cloning process takes an
existing object and creates a new object with a link to the
original---now called a "superobject"---from which it will inherit
methods and data fields. When a method is invoked (or a field is
referenced) and no local value is found, the superobject is checked
for a value, and then its superobject if any, and so on. Methods are
stored in fields, so if you want to replace a clone's method
definition with something else, just define the new method on the
clone, and the superobject's version will be hidden.

* An example of prototypes in Blocky

** Defining a prototype

First we must define a prototype and name its fields:

: (define-prototype rectangle ()
:   x y width height)

We could also have provided initialization forms for the slots, and
documentation strings:

: (define-prototype rectangle ()
:   (x :initform 0 
:      :documentation "The x-coordinate of the rectangle's top-left corner.")
:   (y :initform 0 
:      :documentation "The y-coordinate of the rectangle's top-left corner.")
:   (width :documentation "The width of the rectangle.")
:   (height :documentation "The height of the rectangle."))

** Single inheritance, with :SUPER

And if there was a "shape" prototype, from which we would like
"rectangle" to inherit data and methods, we might have written:

: (define-prototype rectangle (:super shape)
:   (x :initform 0 
:      :documentation "The x-coordinate of the rectangle's top-left corner.")
:   (y :initform 0 
:      :documentation "The y-coordinate of the rectangle's top-left corner.")
:   (width :documentation "The width of the rectangle.")
:   (height :documentation "The height of the rectangle."))

** Cloning objects with NEW

The function NEW is used to create new objects from these
prototypes. Now we write an initializer, which is passed any creation
arguments at the time of cloning.

: (define-method initialize rectangle (&key width height)
:   (setf %width width)
:   (setf %height height))

So, now when you say:

: (let ((my-rectangle
:       (new rectangle :width 5 :height 12)))

The rectangle's initializer method is invoked with those arguments,
and a rectangle of the correct height and width is created.

Notice how field accesses can be written with the percent-sign prefix;
this works both for reading and for writing, so long as you use "setf"
for the latter. You can also get or set field values with the
underlying function FIELD-VALUE:
 
: (field-value :width my-rectangle)
: (setf (field-value :height my-rectangle) 7)

** Methods

Now we define a few methods, which are functions whose implicit first
argument is the object to operate on.

: (define-method area rectangle ()
:   (* %width %height))
: 
: (define-method print-me rectangle (&optional (stream t))
:   (format stream "height: ~A width: ~A area: ~A"
: 	  %height %width 
: 	  (area self)))

You can invoke them like ordinary functions, or use the SEND function.

: (defvar rect (new rectangle :width 10 :height 8))
:
: (print-me rect)

The result: 

: "height: 8 width: 10 area: 80"

Notice how within the body of PRINT-ME, the variable "self" refers to
the object being operated on. So it's easy to see why %foo expands to
(field-value :foo self)

** TODO Extended argument lists
** TODO Serialization

* Visual blocks

When employing the traditional notion of class-as-subtype, our
problem-domain ontology must be divided into classes whose relations
determine which operations (i.e. methods) may be applied to a given
object. But as Alan Perlis famously said, "It is better to have 100
functions operate on one data structure than 10 functions on 10 data
structures." Without the type-theoretic barriers imposed by the
doctrine of class-as-subtype, we can mix and match behaviors more
freely, and methods will tend to be useful on a wider range of
objects.

In the Blocky language, everything is a Block. To explain another way:
all objects in the system---whether they are in-game entities such as
monsters or bullets, or whether they are menus and buttons used to
implement the user interface---ultimately derive their behavior from
the master prototype called "BLOCK". (The purpose of this is to mimic
the Lisp-nature, in which everything is a symbolic expression.)

Object composition is encouraged because all blocks have %inputs

** Basic blocks properties
*** define-block
*** xyz position / dimensions
*** LAYOUT
*** drawing, scaling, blending, opacity
**** WITH-STYLE, DRAW-PATCH
*** ON-EVENT and ON-TEXT-EVENT
*** ON-UPDATE
*** COPY and DEEP-COPY
*** pinning and visibility
*** serialization
*** MAKE-BLOCK and prebuilt data entry blocks
*** the Lisp Listener block
** Composing blocks into trees
*** INPUTS and RESULTS
*** parent and child relationships
** Doing things with blocks
*** Movement
*** ON-MOUSE-DOWN, ON-MOUSE-UP, ON-MOUSE-MOVE
*** ON-CLICK, ON-ALTERNATE-CLICK
*** EVALUATE and RECOMPILE
*** WITH-TARGET
*** WITH-SCRIPT

* Device input and output: console.lisp
** configuration variables (screen size, etc)
** keyboard state
** hooks and message logging
** input events
** joystick data
** configuring the GL viewport
** resources and IOF files
** projects
** images 
** text 



