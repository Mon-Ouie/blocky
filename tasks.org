** TODO ALPHA RELEASE
*** TODO 3 small working examples (movement, blue dot, turtle/ladybug)
*** TODO 2 GUI examples
*** TODO basic documentation
*** TODO tutorial project with links to examples,docs
*** TODO Use Alt as move key
*** TODO pop up shell on M-x



*** TODO [#B] implement make-process coroutines
** TODO FIX BUGS
*** TODO Fix wrong entry type-specifiers
**** TODO [#B] Menu option to change accepted type of an entry
*** TODO [#B] FIX trash drawing children
*** TODO [#C] FIX M-x not focusing input on the prompt

** TODO [#C] Fix the way wiki page resources are stored into separate files...
** TODO [#A] Fix backward insertion of lines from error message into listener
** TODO [#A] Improve the basic command-shell and prompt so that in-engine development is easier. 
** TODO [#B] general purpose resizer/scroller decorator thinger
*** TODO trigger context menu items with click, make block with control-click
*** TODO start using terminal output for status message output
*** TODO Allow user to move entries easier via yellow triangle tab

** TODO Finish implementing the core visual programming language in VMACS
*** defblock var (reference to a var, not a def)  (for lisp vars, script vars, proto names, and fields)
*** defblock let (with drag-off variable refs)
*** defblock link <--- to another wikipage or something
*** script wiki database (like the file system)
*** defblock self
*** define-method "block" has argument names as inputs
*** use a non-rounded box layout and appearance for program elements, with very thin margins
**** retain rounded rectangles for UI/workspace/etc
*** example visual project that can be saved and loaded 
*** general process/statemachine thing for distributing moves over many frames, smooth rubberbanding etc

** TODO Re-examine "invader tactics" source and see what blocks are required to reimplement it
** TODO re-release "Invader"!

** TODO [#A] Flesh out the user-friendly development environment
*** desktop wall morphic http://www.cs.ucsb.edu/~urs/oocsb/self/release/Self-4.0/Tutorial/Morphic/Morphic/Kansas.html
*** KILLER FEATURE: gnome-do/anything.el style search/operate, for quick access to everything
*** always draw menus above script
*** add all missing keyboard characters
*** plus button decorator for lists to add objects (fields, methods, etc)
*** fix ellipsis not displayed on menu items until highlight
**** use something other than ellipses? like my generic tree triangles
*** Read me first: F1, then click on any object for help
*** at startup, show formatted textbox with basic information for new users and "don't show this dialog box again" checkbox
*** file selector dialog (ughhhh)
*** pin toggle button
*** an interactive tutorial project
*** project settings dialog for configuring *screen-width* and *resizable* etc
*** dialog boxes for project save/load!
*** dialog boxes are fancy SEND blocks that send to *system*
*** escape key hide/show terminals/menus
*** display GPL and other licensing in scroll box
*** project settings dialog for configuring *screen-width* and *resizable* etc
****  dialog boxes for project save/load!
****  dialog boxes are fancy SEND blocks that send to *system*
*** escape key hide/show terminals/menus
*** display GPL and other licensing in scroll box
*** yellow comment sticky note boxes
*** morphic-style halos
*** tab and shift-tab for input nav
*** comment block for output messages in listener etc, trap errors
*** TODO [#B] isolate/trap all block errors and display them grayed out with an inspectable error


** TODO [#A] Refactor collision detection to enable various types.
*** delegate actual collision detection to method
*** in cell/move and sprite/move , compute whether a move would cause a collision
*** and then only allow the move to go a certain distance. return number moved
*** then "resting contact" will work; the object won't try to move anymore (if gravity.)
*** implement AABB-quadtree? http://en.wikipedia.org/wiki/Quadtree http://hectorgon.blogspot.com/2006/08/regular-grids-vs-aabb-trees-in-games.html

** TODO Game engine improvements
***  defblock with (introduce local vars) 
***  defblock defresource (a stand-in reference to a resource)
****  should resources be full-fledged objects? 

** TODO [#A] Improve messaging, diagnostic output, and error handling.
*** define-method error shell
*** better error handling for menu methods
*** define-method warning shell
*** redirect messages to message bar. optionally fading notifications with widgets in them

** TODO [#A] explicit "save" and "compile" buttons 
** TODO [#A] send block has socket on left for receiver name, as in Smalltalk-Elements
** TODO [#A] Standard Blocks Library
***  move
***  move to 
***  move onto 
***  [#C] glide 
***  change <var> <amount>
***  set <var> <value>
***  get <var>
***  my <var>
***  turn left
***  turn right
***  point at
***  say
***  think <text> <time>
***  display <image>
***  blend
***  opacity
***  show
***  hide
***  move to front
***  play sound
***  play music
***  stop sound
***  [#C] play note/drum/tempo etc
***  [#B] defblock event, the script tests events on them
****  on play
****  on click
****  on event
***  wait
***  loop
***  dotimes
***  dolist
***  send (to some other object explicitly)
***  method
***  while
***  if
****  display true and false
****  use question marks and occasional symbols
***  when 
***  [#C] wait until <condition>
***  stop script
***  stop all
***  touching
***  ask <question>
***  mouse y
***  mouse x
***  mouse down <number>
***  key down <key>
***  distance to
***  common mathematical operations/relations
***  common logical connectives
***  concatenate <strings>
***  [#C] loudness, loud, sensor value
***  random <min> <max>
***  list ops: length, append, add, delete, insert
***  contains
** TODO [#B] defblock defsprite --- defining sprites
***  merge sprites and blocks?

** TODO [#B] joystick menu to find connected devices x3
** TODO [#B] standardize on "ABXY" for the face buttons, LB RB LT RT for the shoulder buttons
** TODO [#B] popup tape-flag/balloons to show you where you are, like hints about M-x window
** TODO [#B] em-dash and en-dash (optionally font-metric-dependent) for uniform declarative layout
** TODO [#B] click anywhere on terminal line to focus on prompt 
** TODO [#B] test raw string entry
** TODO [#B] allow string-valued method fields. resource id's of method block, uuid?
** TODO Universal access
***  How to handle Translations? keywords in most languages are in English even if comments/variable names are French or Japanese or whatever)
****  translate only meuns?
***  Visual theme-ability for the color-blind and visually-impaired users (larger font, higher contrast etc)
***  Braille keyboard and speech synthesis integration for blind users
** TODO [#B] Bring back old/forms.lisp spreadsheet
***  compilation options
** TODO [#B] interactively type live blocks (space bar instantiates and moves big fat cursor
** TODO [#B] bring menubar and its menus to front when opening menu
** TODO [#B] generic way to wrap functions?
** TODO [#B] review all IOFORMS engine features for blocks to make
** TODO [#B] Make dialogs for all menu options in file:system.lisp 
** TODO [#B] incorporate turtle graphics code into base block prototype (for implementing move/turn/point-in-direction 
** TODO [#C] Fix crash when error in blocky.ini
** TODO [#B] Fix menu behavior: properly check other menu widgets in menubar hit before menu
** TODO [#B] allow any font size to be requested
** TODO [#B] fix argument blocks not being created (AGAIN)
** TODO [#B] list-scroll-decorator
** TODO [#B] reasonable emacs configuration for ioforms dev (imenu etc)
** TODO [#B] send unfocused input to terminal? 
** TODO [#B] button to add arguments to + etc (just drop onto block list)
** TODO [#B] monospace textbox for editing method?
** TODO [#B] disabled menu items, to check for presence of method in target and/or condition
** TODO [#B] fix cursor rendering in prompt not lining up with characters
** TODO [#B] AABB-tree (axis-aligned bounding-box)
** TODO [#C] add generic xbox controller support for analog bumpers (emulate buttons)
** TODO [#C] introduce with-font macro and stop using *block-font* explicitly
** TODO [#C] draw standard svg or bitmap icons for errors, informations, questions, and TREE ARROWS
** TODO [#C] defface with bold, italic, etc
** TODO [#C] "evaluate" and "evaluate and show" buttons
** TODO [#C] update fontlocking rules
** TODO [#C] "render as text lisp" option?
** TODO [#C] data entries have methods, such as 
***  script or page as terminology? script sounds scarily active, page sounds passive
***  one file per script
***  script modes
** TODO [#C] morphic halos?
** TODO [#C] duplicate objects / selection 
** TODO [#C] defblock selection 
** TODO [#C] send message to all blocks in selection
** TODO [#C] use turtle to program polygon vertices and shit a la fluxus
** TODO [#C] block colors/backgrounds in a list subprogram could disappear, making it look like text source code?
** TODO [#C] add more information to method+prototype databases
** TODO [#C] cursor should negate underlying letter, not overpaint
** TODO [#C] general svg image support
** TODO [#C] hilbert curve turtle example 
** TODO [#C] make thing to search for duplicate method defs
** TODO [#C] defblock emacs
** TODO [#C] ALPHA issues for PNG images
<|3b|> you want 'save color values from transparent pixels', and need to make
       sure the pixels are white with 0 alpha
<|3b|> also, looks like you weren't passing blend to draw-circle from
       draw-solid-circle, not that it matters here  [23:46]
** TODO [#C] automatically generate blocky friend faces with given body/face shapes
** TODO [#C] pretty rubberband movement

* OLDER NOTES

** TODO [#C] XALCYON STORYLINE
***  i'm going to learn some of this: http://en.wikipedia.org/wiki/Speech_Synthesis_Markup_Language
***  go for a straight space fantasy, skip the arecibo-message angle
***  the planet is actually a benevolent female intelligence who announces she is dying by taking on too much mass from the surrounding clouds, which will trigger fusion in her core 
***  so she calls on certain people to safely store her memories in bubbles
***  recursive bubble universes , where you explore her memories and retrieve them
***  female synth voice?
***  bring in sanctuary monks?
***  depth of field mipmapping to color distant objects with atmosphere distance/haze?
***  recovering ancient memory bubbles
***  story dialog buttons like Ultima
***  think about game design / story
***  smooth scrolling to follow player
***  smoother speed changes w/analog stick
***  health bar
***  hot zone bubbles
***  collectible bubbles
***  bubbles that you need to leave flares inside of.
***  discover which bubbles resonate with each other
***  drop flares inside those bubbles
** TODO [#C] Implement this GRAPH UI example:
   
Say you want a nice interface helping a designer to explore various
choices of values for two variables---such as a function y=f(x), or
perhaps choose a color interactively from a 2D color field (possibly
via the mouse) while seeing corresponding R/G/B values update (and
vice versa when you edit the RGB values individually.) So we want to
make a rectangle with a clickable/draggable point in it, whose X,Y
position reflects the values of the variables, plus axis labels.

You could write a "native" widget to do this with native drawing
commands, but extending that in various ways (to choosing multiple
points, for example) might be harder---whatever the case, if you want
to make a variation or improvement on this widget, the "native" coders
have to do it.

But, assume for the moment that we've got the following prebuilt
visual blocks, with argument or "socket" names listed in parentheses
after the block name.

  sprite(x,y,z,image,...)  a sprite with operations such as
                           "move :north 5 :pixels" and "on-click :x 50 :y 29"

  world(height,width,sprites,...)  a rectangular gameworld where objects can
                                   exist and collide. operations are things like
                                   draw-background() and add-sprite(sprite, x, y,...)
  
  label(x,y,text)          this can be just a specialized sprite() block.

  number(value,format,...)  an editable number widget.

  text(value)               editable plaintext string 

  send(object,message,{arguments})   invoke a method on the OBJECT

  set(name,value)  locally set the variable named NAME to the value
                     VALUE.

  the(name)        find the value of the variable named NAME.
                   graphically, this may be abbreviated *NAME, or by color.

  my(name)         find the value of this object's NAME field.
                   this is distinct from any local variable with that name.

  new(name)        create a new block of the type NAME, i.e. new("number")

  defblock(name,definition)  define a new block in terms of other blocks

  method(name, block, args)   define a method named NAME on the block BLOCK
                   
(As in Scratch, the "sockets" are the places in the block's onscreen
representation that you plug other blocks into.)

I have actually implemented all the prebuilt blocks mentioned, except
for the last two---defblock exists as a Lisp macro to define blocks,
but there isn't yet a visual block CALLED defblock that does this
visually. And similarly with DEFINE-METHOD. But this isn't hard. All
the basics of what I've described above are shown in the youtube demo
I put up, I just need to revise the graphics parts now that I moved to
OpenGL, plus some layout changes.

Anyway, given these blocks, the rough outline of the visual solution,
starting with a blank page:

1. Add a DEFBLOCK to the blank page.
2. Type "point-chooser" into the NAME socket of the DEFBLOCK.
3. Add a blank WORLD to the page. It shows up as a white 256x256 unit
   square by default, but can be resized, change its background image,
   and add sprites using various commands.
4. Add a new SET block. Enter "graph" in the NAME socket.
5. Drag the blank WORLD into the VALUE socket of the SET block.

   (The idea here is that you now have a WORLD object named "graph")

6.  Drag the resulting SET block into the DEFINITION part of the
DEFBLOCK block.

7. Now you have a DEFBLOCK whose body (so far) creates a blank WORLD
   and makes it available as the value of the local variable named
   GRAPH.

8. By steps similar to steps 4-6 above, create a few more SET blocks:

   SET(X, NEW(NUMBER))
   SET(Y, NEW(NUMBER))
   SET(POINT, NEW(SPRITE))

   Add SEND(THE(GRAPH) ADD THE(SPRITE) 0 0) to the main DEFBLOCK, so
   that the graph starts out with the interactive sprite dot in it.

Now, It's probably not hard to make a simple two-column table widget
with the variable names on the left and the values on the right,
instead of having to make each SET statement individually. But you get
the idea---you have something that looks like a dialog box-ish user
interface already, with labels on the left, interactive value widgets
on the right. 

But the graph doesn't yet actually work, so we must continue.

9. Add a SEND block. For the OBJECT (i.e recipient) socket, put in
   THE(POINT), and enter MOVE-TO as the message name. Add THE(X) and
   THE(Y) as the arguments.

   You now have a block which, when triggered, moves the sprite POINT
   to the location given by the values of the local variables X and Y.

   Switching to a Lispy notation, we now have:
 
    (SEND (THE POINT) MOVE-TO (THE X) (THE Y))

10. Add (METHOD UPDATE (THE X)), and as the definition give the SEND
    block from the previous step. 

    And similarly with (METHOD UPDATE (THE Y)).

12. Add (METHOD CLICK (THE POINT)) and give this as a definition: 
       
         (SEND (THE X) SET-VALUE (MY X))
         (SEND (THE Y) SET-VALUE (MY Y))

13. It's clear we could continue on and improve this with label axes
    and such. 

14. It's easier for people to change this defblock's behavior because
    its logic is expressed entirely in blocks. Well, you don't want to
    encourage copy-and-tweak reuse, but on the other hand requiring
    conceptual coordination between everyone on these
    frequently-customized editing tools would be an object-librarian's
    nightmare. Better to err on the side of people adapting the
    available "scripts" to their immediate tasks-at-hand.

I've been discussing with a friend who's developed quite an extensive
Lisp game engine of his own---I'd like to develop this visual language
toolkit as something not tied to my own game engine, so that my stuff
can work with his code as well.
** TODO [#B] consistent set of colored svg icons, one for each block category (enable compressed views and halos)
** TODO [#C] add least-recently-used pruning for memoize facility
** TODO [#B] allow #RRGGBB color spec in resources



* TODO Example 1: Blocky and the Blue Dot
  DEADLINE: <2011-06-04 Sat>
** TODO keyboard input with moving character
** TODO some text
** TODO clickable things?

* TODO Example 2: Blocky quest

* TODO Example 3: mini xong

* TODO PANGAEA

* Eliminate all compiler warnings. Really.

* Sweep snake trail across multiplying particles in 3 reactor chambers
** TODO refactor collision detection without consing
***  write a function (collision *world*
** TODO default-keybindings as an initform 
** trail upgrade
** drifting hot rad areas that drain HP
** instakill spots
** enemies?
** implement turtle graphics
** L-systems procedural levels http://en.wikipedia.org/wiki/L-system
* TODO Add more documentation for user-visible API things
* TODO [#A] Get visual language builder working
** TODO merge "schema" field into prototypes.lisp field descriptors
** TODO (defmacro define 
** TODO allow (setf (^field object) value) ??
* TODO [#B] fix event list format docstrings
* TODO [#B] watch farbrausch video presentations
* TODO [#C] add vecto support and other prox texture stuff
* TODO BETA RELEASE: GUI stuff
** TODO INVADER TACTICS remake
* TODO timeline: interactive logarithmic time scale with nasa photos that scale., pseudogame
** TODO altering timelines... seeing results of sending objects far back in time.
** TODO you can never go home---sending back in time to early universe allows travel to regions that are not causally connected later (neither is in the observable universe of the other)


* TODO Review Visual language idea roadmap
(02:23:25 PM) dto: did you see my new examples
(02:23:26 PM) dto: of ioforms
(02:23:32 PM) XORBS112: not yet
(02:23:35 PM) dto: http://lispgamesdev.blogspot.com/
(02:23:36 PM) dto: :)
(02:23:45 PM) dto: they're designed to teach the engine.
(02:23:57 PM) dto: but also tell a strangle little story.
(02:24:29 PM) XORBS112: ha
(02:29:34 PM) dto: now that things are coming together with ioforms i'm excited to make an actual new game after this blocky story
(02:29:58 PM) XORBS112: is this running on opengl?
(02:30:02 PM) dto: yes.
(02:30:23 PM) dto: i still haven't figured out text.
(02:30:32 PM) dto: and i'll have to rewrite some of the GUI stuff. but it should be ok.
(02:31:10 PM) XORBS112: I'll be interested to see what you do about GUI
(02:31:25 PM) XORBS112: so far I haven't had much luck with that
(02:31:31 PM) dto: its going to end up looking substantially like the blocks from my recent video
(02:31:42 PM) dto: wher i demoed the blocks ui having some interesting tweaks to the scratch model
(02:33:12 PM) XORBS112: afk for a sec
(02:59:07 PM) XORBS112: back
(03:11:38 PM) XORBS112: interesting
(03:13:48 PM) XORBS112: have you taken a stab at networked games at all?
(03:13:56 PM) dto: no.
(03:15:07 PM) XORBS112: I was fairly proud of the job I did with the networking code in my new game
(03:15:17 PM) dto: i think it would be great to be able to use my visual blocks stuff with your engine
(03:15:26 PM) XORBS112: that would be cool
(03:15:35 PM) XORBS112: my engine needs serious cleanup
(03:15:49 PM) dto: i've been going through that cleanup process. it's painful, but eventually wonderful and awesome
(03:15:58 PM) dto: now things are named consistently
(03:16:04 PM) XORBS112: but I think Lisp could use a high quality game engine
(03:16:15 PM) dto: much obsolete code has been removed. i'm at 6500 lines now.
(03:16:18 PM) XORBS112: I think right now everyone's working in their own little corner
(03:16:21 PM) dto: it was 9k before
(03:16:24 PM) XORBS112: oh nice
(03:16:28 PM) dto: i agree
(03:16:32 PM) dto: (re corner
(03:17:53 PM) XORBS112: I'll make a release of my game engine
(03:17:57 PM) XORBS112: in the next week or so
(03:18:00 PM) dto: cool.
(03:18:03 PM) XORBS112: and let you try it out
(03:18:16 PM) dto: there seemed to be lots of stuff. like physics and even skeletal stuff?
(03:18:20 PM) XORBS112: yeah
(03:18:23 PM) XORBS112: skeleton animation
(03:18:27 PM) XORBS112: particle effects
(03:18:45 PM) XORBS112: arbitrary swept sphere to triangle collisions
(03:18:51 PM) XORBS112: portals
(03:19:25 PM) dto: i think eventually it may be good to re-base my object system onto CLOS (wouldn't be hard) and add some extra compatibility so that my visual Lisp isn't just trapped in a game engine.
(03:19:40 PM) dto: wow.
(03:20:32 PM) XORBS112: yeah
(03:20:34 PM) XORBS112: one question
(03:20:53 PM) XORBS112: is how to interface different games with some sort of a common map system
(03:21:13 PM) dto: what do you mean by map. game worlds?
(03:21:21 PM) XORBS112: I mean like use your visual system
(03:21:27 PM) XORBS112: as a way to write games
(03:21:34 PM) XORBS112: in an engine-agnostic way
(03:21:51 PM) dto: i think i can do that.
(03:22:10 PM) XORBS112: the only thing is
(03:22:18 PM) XORBS112: 2D and 3D games have fairly different requirements
(03:22:26 PM) dto: aha :)
(03:22:32 PM) dto: that's where the visual extensibility comes in.
(03:22:32 PM) XORBS112: spanning that cognitive gap will be interesting
(03:23:06 PM) dto: say you need a 3d world view sort of like the multi-view in blender, where you see plan/elevation etc
(03:23:15 PM) dto: or whatever is "different from the needs of 2d"
(03:23:29 PM) dto: what about an isometric final fantasy tactics like game? needs a different level editor.
(03:23:34 PM) dto: so,
(03:24:01 PM) dto: you could write IOFORMS widgets that bridge the gap.
(03:25:40 PM) dto: i.e. IOFORMS programs are composed of blocks positioned in 3d opengl space, and they can draw themselves however they want using any opengl commands whatsoever, arranged in a display tree so that a block can choose how/whether to draw its children, or whether to draw an interesting data UI instead of show the child widgets, etc.
(03:26:17 PM) dto: i dont imagine it would be that hard to get IOFORMS to display pop ups or whatever, in the same opengl context that you're using your game engine in.
(03:27:00 PM) dto: for example what about all the procedural texturing/modeling buzz
(03:27:31 PM) dto: a lot of that stuff (farbrausch / werkkzeug etc) are visually programmed procedural synthesis/remixing
(03:27:35 PM) dto: that is where we need to go.
(03:27:38 PM) XORBS112: ok
(03:27:44 PM) dto: is this nuts, or making sense?
(03:27:58 PM) XORBS112: I think it makes sense in terms of behavior
(03:28:05 PM) XORBS112: but not necessarily in terms of performance
(03:28:27 PM) XORBS112: I think 3D game engines have to bend over backwards a bit to get good performance
(03:28:29 PM) dto: what are your specific concerns?
(03:28:56 PM) XORBS112: vertex arrays
(03:29:01 PM) XORBS112: for example
(03:29:24 PM) dto: the blocks' methods compile to machine code like any other lisp, and its easy to add additional semantics so that blocks reduce to even smaller expressions
(03:29:51 PM) XORBS112: I'm not sure if I understand how it works 100%
(03:29:53 PM) dto: do you mean just a Lisp array of (x,y,z) points?
(03:30:06 PM) XORBS112: which then gets passed to OpenGL
(03:30:12 PM) XORBS112: and gets stored on teh GPU
(03:30:43 PM) dto: i guess if something is too performance critical it could always have a hand-written version.
(03:30:43 PM) XORBS112: in general, I think things are dealt with in more of a batch-like way
(03:31:00 PM) XORBS112: I'm not sure how to deal with batches in your system
(03:31:12 PM) XORBS112: I think that's the biggest difference
(03:31:23 PM) dto: hmm, in that i'm going for scratch-like "live programming"?
(03:31:36 PM) XORBS112: when everything is an individual object, that costs performance
(03:31:51 PM) XORBS112: do we have one ioform per game world object?
(03:31:59 PM) dto: no
(03:32:35 PM) dto: if you were using ioforms as a visually programmable visual programming language "add-on" and not a game engine
(03:33:22 PM) dto: probably what would be sufficient is to implement blocks that wrap your objects and worlds so that you can at least get at them. 
(03:34:07 PM) dto: that way you can program in terms of them (and therefore implement custom editors in terms of them) .
(03:34:21 PM) dto: now in my case here, I'm using ioforms objects as the game engine too. 
(03:34:48 PM) XORBS112: ok
(03:34:54 PM) dto: the little block character, the blue dot, and the gameworld itself are blocks. the gameworld defines its draw method to paint the background, then the sprites..etc)
(03:34:58 PM) XORBS112: so I could use it as a scripting engine?
(03:35:01 PM) dto: yeah.
(03:35:06 PM) XORBS112: I think that would work
(03:35:16 PM) XORBS112: it would require some refactoring on my part
(03:35:20 PM) XORBS112: (which I need to do anyway)
(03:35:59 PM) dto: keep me posted. i bet i could rework things to suit your concerns.
(03:36:11 PM) dto: have you peeked at any source for a game
(03:36:16 PM) dto:  mean my exampls?
(03:36:40 PM) dto: https://github.com/dto/ioforms/blob/master/example2/example2.lisp

** TODO [#C] GAME IDEA: nested puzzle blox? got to drag your guy through various boxes of different sizes and shapes
***** use recursive collision detection of some kind, to enable boxes to only fit certain things

* Archived Entries
** DONE [#A] rename RUN to EVALUATE
   CLOSED: [2011-07-09 Sat 02:15]
   :PROPERTIES:
   :ARCHIVE_TIME: 2011-07-09 Sat 02:16
   :ARCHIVE_FILE: ~/ioforms/tasks.org
   :ARCHIVE_CATEGORY: tasks
   :ARCHIVE_TODO: DONE
   :END:
** TODO [#A] Read whitepaper: "Programming as an Experience: The Inspiration for Self"
   :PROPERTIES:
   :ARCHIVE_TIME: 2011-07-20 Wed 23:09
   :ARCHIVE_FILE: ~/ioforms/tasks.org
   :ARCHIVE_CATEGORY: tasks
   :ARCHIVE_TODO: TODO
   :END:

